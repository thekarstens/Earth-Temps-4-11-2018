<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Storm Science Lab - Master Map</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="vendor/leaflet-velocity.min.css"/>

<style>
  html, body { height:100%; margin:0; }
  #app { height:100%; display:flex; flex-direction:column; }
  #topbar {
    background:#1f3242; color:#fff; padding:10px 12px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    box-shadow:0 2px 10px rgba(0,0,0,.25);
    z-index:1000;
  }
  #topbar .row1 { display:flex; align-items:center; justify-content:space-between; gap:12px; }
  #title { font-size:22px; font-weight:800; letter-spacing:.5px; }
  #dq { font-size:14px; opacity:.95; margin-top:6px; }
  #controls { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  .btn {
    background:#2b4258; color:white; border:1px solid rgba(255,255,255,.18);
    border-radius:10px; padding:8px 12px; cursor:pointer; font-weight:700;
  }
  .btn:active { transform: translateY(1px); }
  .pill { display:flex; align-items:center; gap:8px; background:#2b4258; border:1px solid rgba(255,255,255,.18); border-radius:999px; padding:6px 10px; }
  #opacity { width:180px; }
  #timeLabel { font-size:18px; font-weight:900; letter-spacing:.6px; }
  #map { flex:1; }
  .leaflet-control-layers-expanded { max-height:60vh; overflow:auto; }
  .tv-city-label {
    background: rgba(255,255,255,.95);
    border-radius: 10px;
    padding: 2px 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,.25);
    border: 1px solid rgba(0,0,0,.15);
    font-weight: 800;
    color: #111;
  }
  #logoWrap {
    position:absolute; right:16px; bottom:12px; z-index:1200;
    display:flex; align-items:flex-end; gap:10px;
    pointer-events:none;
  }
  #logoWrap img { height:90px; width:auto; filter: drop-shadow(0 10px 18px rgba(0,0,0,.35)); }
  #legend {
    pointer-events:none;
    background: rgba(31,50,66,.85); color:#fff;
    border-radius:12px; padding:8px 10px; font-size:12px; line-height:1.25;
    border:1px solid rgba(255,255,255,.18);
    max-width:260px;
  }
  #legend .h { font-weight:900; margin-bottom:6px; }
</style>
</head>
<body>
<div id="app">
  <div id="topbar">
    <div class="row1">
      <div>
        <div id="title">LESSON 1: DRIVING QUESTION</div>
        <div id="dq">QUESTION: How can we use real-time weather data to make safer decisions?</div>
      </div>
      <div id="controls">
        <button id="modeBtn" class="btn">STUDENT</button>
        <div class="pill"><span style="font-weight:900;">OPACITY</span><input id="opacity" type="range" min="0" max="1" step="0.05" value="0.65"/></div>
        <button id="prevBtn" class="btn">◀</button>
        <div id="timeLabel">—</div>
        <button id="nextBtn" class="btn">▶</button>
      </div>
    </div>
  </div>
  <div id="map"></div>
</div>

<div id="logoWrap">
  <div id="legend">
    <div class="h">Legend</div>
    <div id="legendBody">Toggle layers at top right.</div>
  </div>
  <img src="storm_science_lab_logo.png" alt="Storm Science Lab"/>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.min.js"></script>
<script src="vendor/leaflet-velocity.min.js"></script>

<script>
(function() {
  function ymdFromISOZ(iso) { return (iso || "").split("T")[0]; }

  const TIME_STEPS = [
  {
    "label": "APRIL 14, 2018 7AM",
    "radar": "n0q_201804141200.png",
    "metars": null
  },
  {
    "label": "APRIL 14, 2018 10AM",
    "radar": "n0q_201804141500.png",
    "metars": null
  },
  {
    "label": "APRIL 14, 2018 1PM",
    "radar": "n0q_201804141800.png",
    "metars": null
  },
  {
    "label": "APRIL 14, 2018 4PM",
    "radar": "n0q_201804142100.png",
    "metars": null
  },
  {
    "label": "APRIL 14, 2018 6PM",
    "radar": "n0q_201804142300.png",
    "metars": null
  }
];

  let stepIndex = 0;
  let isTeacher = false;

  const map = L.map('map', {
    center: [44.3, -96.5],
    zoom: 5,
    minZoom: 3,
    maxZoom: 12,
    zoomControl: true,
    scrollWheelZoom: true
  });

  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const overlays = {};

  // Radar
  const RADAR_IMAGE_BOUNDS = L.latLngBounds(
    L.latLng(14.9763, -133.029),
    L.latLng(55.5480, -49.5580)
  );
  let radarOverlay = null;

  function updateRadar(step) {
    const url = step.radar || null;
    if (!url) return;
    if (radarOverlay) radarOverlay.setUrl(url);
    else radarOverlay = L.imageOverlay(url, RADAR_IMAGE_BOUNDS, { opacity: getOverlayOpacity() });
    if (!map.hasLayer(radarOverlay)) radarOverlay.addTo(map);
  }
  overlays["Composite Radar (Observed)"] = { get layer() { return radarOverlay; } };

  // Fronts + symbols
  const frontsGroup = L.layerGroup();
  function styleFrontFeature(feat) {
    const t = ((feat.properties && (feat.properties.front || feat.properties.type || feat.properties.kind)) || "").toLowerCase();
    if (t.includes("warm")) return { color: "#d52b2b", weight: 5, opacity: 1 };
    if (t.includes("cold")) return { color: "#1e88e5", weight: 5, opacity: 1 };
    if (t.includes("stationary") || t.includes("occluded")) return { color: "#7b1fa2", weight: 5, opacity: 1, dashArray:"8 8" };
    return { color: "#333", weight: 4, opacity: 1 };
  }

  function addFrontSymbols(line, type) {
    const isCold = type.includes("cold");
    const isWarm = type.includes("warm");
    if (!isCold && !isWarm) return;

    const color = isCold ? "#1e88e5" : "#d52b2b";
    const html = isCold
      ? `<svg width="18" height="18" viewBox="0 0 18 18"><polygon points="9,2 16,16 2,16" fill="${color}"></polygon></svg>`
      : `<svg width="18" height="18" viewBox="0 0 18 18"><path d="M2,10 a7,7 0 0 1 14,0" fill="none" stroke="${color}" stroke-width="5" stroke-linecap="round"></path></svg>`;

    const symbol = L.Symbol.marker({
      rotate: true,
      markerOptions: {
        icon: L.divIcon({ className:"", iconSize:[18,18], iconAnchor:[9,9], html })
      }
    });

    const offset = isCold ? -8 : 8; // warm on opposite side
    const decorator = L.polylineDecorator(line, {
      patterns: [{
        offset: 12,
        repeat: 45,
        symbol: L.Symbol.offset({ offset, symbol })
      }]
    });
    frontsGroup.addLayer(decorator);
  }

  function renderFronts(data) {
    frontsGroup.clearLayers();

    const frontLines = L.geoJSON(data, {
      filter: (feat) => {
        const t = ((feat.properties && (feat.properties.front || feat.properties.type || feat.properties.kind)) || "").toLowerCase();
        return t.includes("front");
      },
      style: styleFrontFeature,
      onEachFeature: (feat, layer) => {
        const t = ((feat.properties && (feat.properties.front || feat.properties.type || feat.properties.kind)) || "").toLowerCase();
        addFrontSymbols(layer, t);
      }
    });

    const highsLows = L.geoJSON(data, {
      filter: (feat) => {
        const t = ((feat.properties && (feat.properties.type || feat.properties.kind)) || "").toLowerCase();
        return t === "h" || t === "high" || t === "l" || t === "low";
      },
      pointToLayer: (feat, latlng) => {
        const t = ((feat.properties && (feat.properties.type || feat.properties.kind)) || "").toLowerCase();
        const isH = (t === "h" || t === "high");
        const letter = isH ? "H" : "L";
        const col = isH ? "#1e88e5" : "#d52b2b";
        const html = `<div style="width:44px;height:44px;border-radius:50%;background:rgba(255,255,255,.95);border:3px solid rgba(0,0,0,.18);display:flex;align-items:center;justify-content:center;font-weight:1000;font-size:28px;color:${col};box-shadow:0 2px 10px rgba(0,0,0,.25);">${letter}</div>`;
        return L.marker(latlng, { icon: L.divIcon({ className:"", html, iconSize:[44,44], iconAnchor:[22,22] }) });
      }
    });

    frontsGroup.addLayer(frontLines);
    frontsGroup.addLayer(highsLows);
  }

  async function loadFronts() {
    const resp = await fetch("fronts.geojson");
    const data = await resp.json();
    renderFronts(data);
  }
  overlays["Fronts (Surface Analysis)"] = frontsGroup;

  // MODIS
  let modisLayer = null;
  function buildModisLayer(ymd) {
    const tileUrl = `https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Terra_CorrectedReflectance_TrueColor/default/${ymd}/GoogleMapsCompatible_Level9/{z}/{y}/{x}.jpg`;
    return L.tileLayer(tileUrl, { maxZoom: 9, opacity: getOverlayOpacity() });
  }
  function updateModis(step) {
    const ymd = step.ymd || ymdFromISOZ(step.iso || "");
    if (!ymd) return;
    if (modisLayer) { map.removeLayer(modisLayer); modisLayer = null; }
    modisLayer = buildModisLayer(ymd);
  }
  overlays["MODIS Satellite (True Color)"] = { get layer() { return modisLayer; } };

  // ERA5
  const WORLD_BOUNDS = L.latLngBounds([-85, -180], [85, 180]);
  let era5_0410 = null, era5_0411 = null;
  function initEra5() {
    era5_0410 = L.imageOverlay("era5_t2m_global_2018-04-10_21Z_F_mercator_overlay.png", WORLD_BOUNDS, { opacity: getOverlayOpacity() });
    era5_0411 = L.imageOverlay("era5_t2m_global_2018-04-11_21Z_F_mercator_overlay.png", WORLD_BOUNDS, { opacity: getOverlayOpacity() });
  }
  overlays["Global Temp (ERA5) – Apr 10 (21Z)"] = { get layer() { return era5_0410; } };
  overlays["Global Temp (ERA5) – Apr 11 (21Z)"] = { get layer() { return era5_0411; } };

  // METARs (IEM)
  const metarGroup = L.layerGroup();
  overlays["METAR Observations (IEM)"] = metarGroup;

  function metarUrl(step) {
    const ymd = step.ymd || ymdFromISOZ(step.iso || "");
    const iso = step.iso || `${ymd}T12:00Z`;
    const dt = new Date(iso);
    const y = dt.getUTCFullYear();
    const mo = String(dt.getUTCMonth()+1).padStart(2,"0");
    const d = String(dt.getUTCDate()).padStart(2,"0");
    const h = String(dt.getUTCHours()).padStart(2,"0");
    const min = String(dt.getUTCMinutes()).padStart(2,"0");
    return `https://mesonet.agron.iastate.edu/cgi-bin/request/asos.py?data=all&tz=Etc/UTC&format=geojson&latlon=yes&year1=${y}&month1=${mo}&day1=${d}&hour1=${h}&minute1=${min}&year2=${y}&month2=${mo}&day2=${d}&hour2=${h}&minute2=${min}`;
  }

  let metarAbort = null;
  async function updateMetars(step) {
    if (!map.hasLayer(metarGroup)) return;
    if (metarAbort) metarAbort.abort();
    metarAbort = new AbortController();
    try {
      const resp = await fetch(metarUrl(step), { signal: metarAbort.signal });
      const gj = await resp.json();
      metarGroup.clearLayers();
      const layer = L.geoJSON(gj, {
        pointToLayer: (feat, latlng) => {
          const p = feat.properties || {};
          const temp = (p.tmpf ?? p.tmpc ?? "");
          const id = p.station || p.id || "";
          const html = `<div class="tv-city-label" style="font-size:12px;">${id} ${temp!==""?temp+"°":""}</div>`;
          return L.marker(latlng, { icon: L.divIcon({ className:"", html, iconSize:[1,1] }) });
        }
      });
      metarGroup.addLayer(layer);
    } catch(e) {
      if (e.name !== "AbortError") console.warn("METAR fetch failed:", e);
    }
  }

  // Wind particles
  const surfaceParticles = L.layerGroup();
  const jetParticles = L.layerGroup();
  overlays["Surface Wind Particles (NARR daily)"] = surfaceParticles;
  overlays["Jet Stream Particles (250mb)"] = jetParticles;

  let surfaceVelocity = null;
  let jetVelocity = null;

  async function ensureVelocityLayer(group, url, setRef) {
    const resp = await fetch(url);
    const data = await resp.json();
    const layer = L.velocityLayer({
      displayValues: false,
      data,
      maxVelocity: 60,
      velocityScale: 0.01,
      opacity: getOverlayOpacity()
    });
    group.clearLayers();
    group.addLayer(layer);
    setRef(layer);
  }

  async function updateParticles() {
    if (map.hasLayer(surfaceParticles) && !surfaceVelocity) {
      await ensureVelocityLayer(surfaceParticles, "narr_10m_wind_20180414_daily_mph.json", (l)=>surfaceVelocity=l);
    }
    if (map.hasLayer(jetParticles) && !jetVelocity) {
      await ensureVelocityLayer(jetParticles, "jetstream/jetstream_250mb_20180414_18Z.json", (l)=>jetVelocity=l);
    }
  }

  // City labels
  const cityGroup = L.layerGroup().addTo(map);
  const cities = [
    {name:"Rapid City", lat:44.08, lon:-103.23, z:6},
    {name:"Pierre", lat:44.37, lon:-100.35, z:6},
    {name:"Sioux Falls", lat:43.55, lon:-96.73, z:6},
    {name:"Omaha", lat:41.26, lon:-96.00, z:6},
    {name:"Des Moines", lat:41.58, lon:-93.62, z:6},
    {name:"Minneapolis", lat:44.98, lon:-93.26, z:6},
    {name:"Chicago", lat:41.88, lon:-87.63, z:5},
    {name:"Kansas City", lat:39.10, lon:-94.58, z:6},
    {name:"Denver", lat:39.74, lon:-104.99, z:5},
    {name:"Cleveland", lat:41.50, lon:-81.69, z:6},
    {name:"Buffalo", lat:42.89, lon:-78.87, z:6}
  ];
  function refreshCityLabels() {
    const z = map.getZoom();
    cityGroup.clearLayers();
    for (const c of cities) {
      if (z >= c.z) {
        const m = L.marker([c.lat, c.lon], {
          interactive:false,
          icon: L.divIcon({ className:"", html:`<div class="tv-city-label">${c.name}</div>`, iconSize:[1,1] })
        });
        cityGroup.addLayer(m);
      }
    }
  }
  map.on("zoomend", refreshCityLabels);
  refreshCityLabels();

  // Layer control
  function resolveLayer(objOrLayer) {
    if (!objOrLayer) return null;
    if (objOrLayer instanceof L.Layer) return objOrLayer;
    if (objOrLayer.layer instanceof L.Layer) return objOrLayer.layer;
    if (typeof objOrLayer.layer !== "undefined") return objOrLayer.layer;
    return null;
  }

  const layerControl = L.control.layers({"OpenStreetMap": osm}, {}, { collapsed:false }).addTo(map);

  for (const [name, obj] of Object.entries(overlays)) {
    const lyr = resolveLayer(obj);
    if (lyr) layerControl.addOverlay(lyr, name);
    else {
      const dummy = L.layerGroup();
      layerControl.addOverlay(dummy, name);
      overlays[name] = Object.assign({}, obj, { _dummy: dummy });
    }
  }

  function getOverlayOpacity() { return parseFloat(document.getElementById("opacity").value || "0.65"); }

  function setOpacityOnLayer(layer, op) {
    if (!layer) return;
    if (layer.setOpacity) layer.setOpacity(op);
    if (layer.options) layer.options.opacity = op;
    if (layer._canvas) layer._canvas.style.opacity = op;
  }

  function applyOpacity() {
    const op = getOverlayOpacity();
    if (radarOverlay) setOpacityOnLayer(radarOverlay, op);
    if (modisLayer) setOpacityOnLayer(modisLayer, op);
    if (era5_0410) setOpacityOnLayer(era5_0410, op);
    if (era5_0411) setOpacityOnLayer(era5_0411, op);
    if (surfaceVelocity) setOpacityOnLayer(surfaceVelocity, op);
    if (jetVelocity) setOpacityOnLayer(jetVelocity, op);
  }
  document.getElementById("opacity").addEventListener("input", applyOpacity);

  map.on("overlayadd", (e) => {
    const name = Object.keys(overlays).find(k => overlays[k]._dummy === e.layer);
    if (!name) return;

    if (name.startsWith("MODIS")) {
      updateModis(TIME_STEPS[stepIndex]);
      if (modisLayer) { modisLayer.addTo(map); applyOpacity(); }
    }
    if (name.startsWith("Global Temp (ERA5) – Apr 10")) { if (!era5_0410) initEra5(); era5_0410.addTo(map); applyOpacity(); }
    if (name.startsWith("Global Temp (ERA5) – Apr 11")) { if (!era5_0411) initEra5(); era5_0411.addTo(map); applyOpacity(); }
    if (name.startsWith("Composite Radar")) { if (radarOverlay) radarOverlay.addTo(map); }
    if (name.startsWith("METAR")) updateMetars(TIME_STEPS[stepIndex]);
    if (name.startsWith("Surface Wind") || name.startsWith("Jet Stream")) updateParticles();
  });

  // Timeline
  function renderTimeLabel(step) {
    document.getElementById("timeLabel").textContent = step.label || step.iso || step.ymd || "";
  }

  function updateAll() {
    const step = TIME_STEPS[stepIndex];
    renderTimeLabel(step);
    updateRadar(step);
    updateModis(step);
    updateMetars(step);
    updateParticles();
    applyOpacity();
  }

  document.getElementById("prevBtn").addEventListener("click", () => {
    stepIndex = (stepIndex - 1 + TIME_STEPS.length) % TIME_STEPS.length;
    updateAll();
  });
  document.getElementById("nextBtn").addEventListener("click", () => {
    stepIndex = (stepIndex + 1) % TIME_STEPS.length;
    updateAll();
  });

  document.getElementById("modeBtn").addEventListener("click", () => {
    isTeacher = !isTeacher;
    document.getElementById("modeBtn").textContent = isTeacher ? "TEACHER" : "STUDENT";
  });

  loadFronts().catch((e)=>console.warn("Fronts load failed:", e));
  updateAll();
})();
</script>
</body>
</html>
